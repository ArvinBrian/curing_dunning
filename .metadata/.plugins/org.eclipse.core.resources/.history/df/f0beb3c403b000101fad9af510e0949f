package com.example.curingdunning.service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.temporal.ChronoUnit;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.example.curingdunning.dto.DunningEventDTO;
import com.example.curingdunning.entity.Customer;
import com.example.curingdunning.entity.DunningEvent;
import com.example.curingdunning.entity.DunningRule;
import com.example.curingdunning.entity.PlanType;
import com.example.curingdunning.entity.ServiceSubscription;
import com.example.curingdunning.repository.CustomerRepository;
import com.example.curingdunning.repository.DunningEventRepository;
import com.example.curingdunning.repository.DunningRuleRepository;
import com.example.curingdunning.repository.ServiceSubscriptionRepository;

import jakarta.transaction.Transactional;

@Service
public class DunningEventService {

    @Autowired 
    private DunningEventRepository eventRepo;

    @Autowired 
    private DunningRuleRepository ruleRepo;

    @Autowired 
    private ServiceSubscriptionRepository subRepo;

    @Autowired 
    private CustomerRepository customerRepo;

    private final Logger log = LoggerFactory.getLogger(getClass());

    /**
     * Generate events for all customers by scanning subscriptions and rules.
     * Supports mobile plans only, differentiates prepaid and postpaid.
     */
    @Transactional
    public void generateEventsForAllCustomers() {
        LocalDate today = LocalDate.now();
        LocalTime now = LocalTime.now();

        List<ServiceSubscription> subs = subRepo.findByServiceName("Mobile"); // mobile only

        for (ServiceSubscription sub : subs) {
            Customer customer = sub.getCustomer();
            PlanType plan = sub.getPlanType();

            if (plan == PlanType.POSTPAID) {
                handlePostpaid(sub, customer, today);
            } else if (plan == PlanType.PREPAID) {
                handlePrepaid(sub, customer, now);
            }
        }
    }

    private void handlePostpaid(ServiceSubscription sub, Customer customer, LocalDate today) {
        int daysOverdue = (int) ChronoUnit.DAYS.between(sub.getNextDueDate(), today);
        if (daysOverdue <= 0) return; // not overdue

        // fetch applicable rules
        List<DunningRule> rules = ruleRepo.findByServiceNameAndPlanType("Mobile", PlanType.POSTPAID)
                .stream()
                .filter(r -> r.getOverdueDays() != null && daysOverdue >= r.getOverdueDays())
                .sorted(Comparator.comparing(r -> r.getPriority() == null ? Integer.MAX_VALUE : r.getPriority()))
                .collect(Collectors.toList());

        if (rules.isEmpty()) return;

        DunningRule chosen = rules.get(0);

        // avoid duplicate events for same customer/service/rule
        boolean exists = eventRepo.findByCustomerCustomerIdOrderByCreatedAtDesc(customer.getCustomerId())
                .stream()
                .anyMatch(e -> e.getServiceName().equals("Mobile") && !"RESOLVED".equals(e.getStatus()));
        if (exists) return;

        // create event
        DunningEvent ev = new DunningEvent();
        ev.setCustomer(customer);
        ev.setServiceName("Mobile");
        ev.setDaysOverdue(daysOverdue);
        ev.setStatus("PENDING");
        ev.setTriggeredBy("SYSTEM");
        ev.setCreatedAt(LocalDateTime.now());
        eventRepo.save(ev);

        log.info("Postpaid event created: customer={} daysOverdue={} rule={}", customer.getCustomerId(), daysOverdue, chosen.getId());
    }

    private void handlePrepaid(ServiceSubscription sub, Customer customer, LocalTime now) {
        // get rules for prepaid mobile
        List<DunningRule> rules = ruleRepo.findByServiceNameAndPlanType("Mobile", PlanType.PREPAID)
                .stream()
                .filter(r -> r.getTimeOfDay() != null && !r.getTimeOfDay().isAfter(now))
                .sorted(Comparator.comparing(r -> r.getPriority() == null ? Integer.MAX_VALUE : r.getPriority()))
                .collect(Collectors.toList());

        for (DunningRule r : rules) {
            // check if an unresolved event already exists
            boolean exists = eventRepo.findByCustomerCustomerIdOrderByCreatedAtDesc(customer.getCustomerId())
                    .stream()
                    .anyMatch(e -> e.getServiceName().equals("Mobile") && !"RESOLVED".equals(e.getStatus()));
            if (exists) continue;

            // create event
            DunningEvent ev = new DunningEvent();
            ev.setCustomer(customer);
            ev.setServiceName("Mobile");
            ev.setDaysOverdue(0); // prepaid is time-based
            ev.setStatus("PENDING");
            ev.setTriggeredBy("SYSTEM");
            ev.setCreatedAt(LocalDateTime.now());
            eventRepo.save(ev);

            log.info("Prepaid event created: customer={} time={} rule={}", customer.getCustomerId(), r.getTimeOfDay(), r.getId());
        }
    }

    public List<DunningEventDTO> getEventsForCustomer(Long customerId) {
        return eventRepo.findByCustomerCustomerIdOrderByCreatedAtDesc(customerId)
                .stream()
                .map(this::toDto)
                .collect(Collectors.toList());
    }

    private DunningEventDTO toDto(DunningEvent e) {
        DunningEventDTO dto = new DunningEventDTO();
        dto.setEventId(e.getId());
        dto.setServiceName(e.getServiceName());
        dto.setDaysOverdue(e.getDaysOverdue());
        dto.setStatus(e.getStatus());
        dto.setCreatedAt(e.getCreatedAt());
        return dto;
    }

    @Transactional
    public void markResolved(Long eventId, Long actionId) {
        DunningEvent ev = eventRepo.findById(eventId).orElseThrow(() -> new RuntimeException("Event not found"));
        ev.setStatus("RESOLVED");
        ev.setResolvedAt(LocalDateTime.now());
        ev.setAppliedActionId(actionId);
        eventRepo.save(ev);

        // reset negative effects on customer/subscription
        ServiceSubscription sub = subRepo.findByCustomerCustomerIdAndServiceName(ev.getCustomer().getCustomerId(), ev.getServiceName())
                .orElseThrow(() -> new RuntimeException("Subscription not found"));
        // reset throttles, call bars, etc. as needed
        log.info("Customer {} subscription {} reset after action {}", ev.getCustomer().getCustomerId(), ev.getServiceName(), actionId);
    }
}
