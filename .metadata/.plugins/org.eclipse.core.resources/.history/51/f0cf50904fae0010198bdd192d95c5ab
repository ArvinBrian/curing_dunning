package com.example.curingdunning.service;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.example.curingdunning.dto.ApplyActionDTO;
import com.example.curingdunning.dto.CuringActionDTO;
import com.example.curingdunning.entity.CuringAction;
import com.example.curingdunning.entity.DunningEvent;
import com.example.curingdunning.repository.CuringActionRepository;
import com.example.curingdunning.repository.DunningEventRepository;

import jakarta.transaction.Transactional;

@Service
public class CuringActionService {

    @Autowired private CuringActionRepository actionRepo;
    @Autowired private DunningEventService eventService;
    @Autowired private DunningEventRepository eventRepo;

    @Transactional
    public void applyAction(ApplyActionDTO dto) {
        DunningEvent event = eventRepo.findById(dto.getEventId())
            .orElseThrow(() -> new RuntimeException("Event not found"));

        CuringAction action = actionRepo.findById(dto.getActionId())
            .orElseThrow(() -> new RuntimeException("Action not found"));

        // Execute action side-effects (in real app: call payment gateway, recharge service, etc)
        // Here: simulate side-effect and mark event resolved
        // For idempotency: if event already RESOLVED, just return
        if ("RESOLVED".equals(event.getStatus())) return;

        // Example: if actionName == "PAY_BILL" -> verify payment succeeded
        // Simulate success:
        boolean success = true;

        if (success) {
            event.setStatus("RESOLVED");
            event.setAppliedActionId(action.getId());
            event.setResolvedAt(LocalDateTime.now());
            eventRepo.save(event);
        } else {
            // optionally log failure and keep event PENDING
            throw new RuntimeException("Failed to apply action");
        }
    }

    public List<CuringActionDTO> getAvailableActionsForCustomer(Long customerId, String serviceName) {
        // For now return actions by serviceName
        return actionRepo.findByServiceName(serviceName)
                .stream()
                .map(a -> {
                    CuringActionDTO dto = new CuringActionDTO();
                    dto.setId(a.getId());
                    dto.setActionName(a.getActionName());
                    dto.setServiceName(a.getServiceName());
                    dto.setDescription(a.getDescription());
                    return dto;
                }).collect(Collectors.toList());
    }

    public List<CuringActionDTO> getAvailableActionsForCustomer(Long customerId) {
        // returns actions across all services the customer has subscriptions for (simpler route: return all actions)
        return actionRepo.findAll().stream().map(a -> {
            CuringActionDTO dto = new CuringActionDTO();
            dto.setId(a.getId());
            dto.setActionName(a.getActionName());
            dto.setServiceName(a.getServiceName());
            dto.setDescription(a.getDescription());
            return dto;
        }).collect(Collectors.toList());
    }
}
