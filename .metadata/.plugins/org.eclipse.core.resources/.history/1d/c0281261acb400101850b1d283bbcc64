package com.example.curingdunning.service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.temporal.ChronoUnit;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.example.curingdunning.dto.DunningEventDTO;
import com.example.curingdunning.entity.Customer;
import com.example.curingdunning.entity.DunningEvent;
import com.example.curingdunning.entity.DunningRule;
import com.example.curingdunning.entity.PlanType;
import com.example.curingdunning.entity.ServiceSubscription;
import com.example.curingdunning.repository.CustomerRepository;
import com.example.curingdunning.repository.DunningEventRepository;
import com.example.curingdunning.repository.DunningRuleRepository;
import com.example.curingdunning.repository.ServiceSubscriptionRepository;

import jakarta.transaction.Transactional;

@Service
public class DunningEventService {

    @Autowired 
    private DunningEventRepository eventRepo;

    @Autowired 
    private DunningRuleRepository ruleRepo;

    @Autowired 
    private ServiceSubscriptionRepository subRepo;

    @Autowired 
    private CustomerRepository customerRepo;

    private final Logger log = LoggerFactory.getLogger(getClass());

    /**
     * Generate events for all customers by scanning subscriptions and rules.
     * Supports mobile plans only, differentiates prepaid and postpaid.
     */
    
    @Transactional
    public void handlePrepaid(ServiceSubscription sub, Customer customer, LocalDate today) {
        long daysOverdue = ChronoUnit.DAYS.between(sub.getNextDueDate(), today);
        if (daysOverdue < 0) return; // not overdue yet

        // fetch applicable rules
        List<DunningRule> rules = ruleRepo.findByServiceNameAndPlanType("Mobile", PlanType.PREPAID)
                .stream()
                .filter(r -> r.getOverdueDays() != null && daysOverdue >= r.getOverdueDays())
                .sorted(Comparator.comparingInt(r -> r.getPriority() != null ? r.getPriority() : Integer.MAX_VALUE))
                .collect(Collectors.toList());

        if (rules.isEmpty()) return;

        DunningRule chosen = rules.get(rules.size() - 1);

        // avoid duplicate events for same rule/action
        boolean exists = eventRepo.findByCustomerCustomerIdOrderByCreatedAtDesc(customer.getCustomerId())
                .stream()
                .anyMatch(e -> e.getServiceName().equals("Mobile")
                            && !"RESOLVED".equals(e.getStatus())
                            && e.getAppliedRule() != null
                            && e.getAppliedRule().getAction().equals(chosen.getAction()));
        if (exists) return;

        // create event
        DunningEvent ev = new DunningEvent();
        ev.setCustomer(customer);
        ev.setServiceName("Mobile");
        ev.setDaysOverdue((int) daysOverdue);
        ev.setStatus("PENDING");
        ev.setTriggeredBy("SYSTEM");
        ev.setCreatedAt(LocalDateTime.now());
        ev.setAppliedRule(chosen);
        eventRepo.save(ev);

        // Apply action (e.g., throttle data, bar calls)
        if ("THROTTLE_DATA".equals(chosen.getAction()) || "BAR_OUTGOING_CALLS".equals(chosen.getAction())) {
            sub.setStatus("BLOCKED");
            subRepo.save(sub);
        }

        log.info("Prepaid event created: customer={} daysOverdue={} rule={} action={}", 
                 customer.getCustomerId(), daysOverdue, chosen.getId(), chosen.getAction());
    }


    public void handlePostpaid(ServiceSubscription sub, Customer customer, LocalDate today) {
        long daysOverdue = ChronoUnit.DAYS.between(sub.getNextPaymentDate(), today);
        if (daysOverdue < 0) return; // not overdue yet

        // fetch applicable rules
        List<DunningRule> rules = ruleRepo.findByServiceNameAndPlanType("Mobile", PlanType.POSTPAID)
                .stream()
                .filter(r -> r.getOverdueDays() != null && daysOverdue >= r.getOverdueDays())
                .sorted(Comparator.comparingInt(r -> r.getPriority() != null ? r.getPriority() : Integer.MAX_VALUE))
                .collect(Collectors.toList());

        if (rules.isEmpty()) return;

        DunningRule chosen = rules.get(rules.size() - 1);

        // avoid duplicate events for same rule/action
        boolean exists = eventRepo.findByCustomerCustomerIdOrderByCreatedAtDesc(customer.getCustomerId())
                .stream()
                .anyMatch(e -> e.getServiceName().equals("Mobile")
                            && !"RESOLVED".equals(e.getStatus())
                            && e.getAppliedRule() != null
                            && e.getAppliedRule().getAction().equals(chosen.getAction()));
        if (exists) return;

        // create event
        DunningEvent ev = new DunningEvent();
        ev.setCustomer(customer);
        ev.setServiceName("Mobile");
        ev.setDaysOverdue((int) daysOverdue);
        ev.setStatus("PENDING");
        ev.setTriggeredBy("SYSTEM");
        ev.setCreatedAt(LocalDateTime.now());
        ev.setAppliedRule(chosen);
        eventRepo.save(ev);

        // Apply action (e.g., throttle speed, bar calls)
        if ("THROTTLE_SPEED".equals(chosen.getAction()) || "DATA_LIMIT_REACHED".equals(chosen.getAction())) {
            sub.setStatus("BLOCKED");
            subRepo.save(sub);
        }

        log.info("Postpaid event created: customer={} daysOverdue={} rule={} action={}", 
                 customer.getCustomerId(), daysOverdue, chosen.getId(), chosen.getAction());
    }

    


    @Transactional
    public void markResolved(Long eventId, Long ruleId) {
        // Fetch the event
        DunningEvent ev = eventRepo.findById(eventId)
                .orElseThrow(() -> new RuntimeException("Event not found"));

        // Fetch the applied rule
        DunningRule rule = ruleRepo.findById(ruleId)
                .orElseThrow(() -> new RuntimeException("Rule not found"));

        // Update event details
        ev.setStatus("RESOLVED");
        ev.setResolvedAt(LocalDateTime.now());
        ev.setAppliedRule(rule);
        eventRepo.save(ev);

        // Fetch customer's subscription
        List<ServiceSubscription> subs = subRepo.findByCustomerCustomerIdAndServiceName(
            ev.getCustomer().getCustomerId(),
            ev.getServiceName()
        );

        if (subs.isEmpty()) {
            throw new RuntimeException("Subscription not found");
        }

        ServiceSubscription sub = subs.get(0);
        sub.setStatus("ACTIVE");
        subRepo.save(sub);

        log.info("Customer {} subscription {} reset to ACTIVE after resolving rule {}",
                 ev.getCustomer().getCustomerId(), ev.getServiceName(), rule.getId());
    }



}
