package com.example.curingdunning.service;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import com.example.curingdunning.dto.BillDTO;
import com.example.curingdunning.entity.Bill;
import com.example.curingdunning.entity.Customer;
import com.example.curingdunning.entity.DunningEvent;
import com.example.curingdunning.entity.DunningRule;
import com.example.curingdunning.entity.PlanType;
import com.example.curingdunning.entity.ServiceSubscription;
import com.example.curingdunning.exception.CustomerNotFoundException;
import com.example.curingdunning.repository.BillRepository;
import com.example.curingdunning.repository.CustomerRepository;
import com.example.curingdunning.repository.DunningEventRepository;
import com.example.curingdunning.repository.DunningRuleRepository;
import com.example.curingdunning.repository.ServiceSubscriptionRepository;

import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
public class BillServiceImpl implements BillService {

    private static final int EOC_TRIGGER_DAYS_BEFORE = 5; // Add this constant
    
	@Autowired
	private BillRepository billRepo;

	@Autowired
	private CustomerRepository customerRepo;

	@Autowired
	private DunningEventRepository eventRepo;

	@Autowired
	private ServiceSubscriptionRepository subRepo;

	@Autowired
	private DunningEventService dunningEventService;
	
	@Autowired
	private DunningRuleRepository ruleRepo;

	@Scheduled(fixedRate = 86400000) // every 24 hours
	public void processScheduledBillingAndOverdues() {
	    LocalDate today = LocalDate.now();

	    // 1. âœ… Generate Upcoming/End-of-Cycle Bills
	    List<Customer> customers = customerRepo.findAll();

	    for (Customer customer : customers) {
	        List<ServiceSubscription> subscriptions = subRepo
	                .findByCustomerCustomerIdAndStatus(customer.getCustomerId(), "ACTIVE");

	        for (ServiceSubscription sub : subscriptions) {
	            LocalDate nextPaymentDate = sub.getNextPaymentDate();
	            if (nextPaymentDate == null)
	                continue;

	            long daysUntilPayment = ChronoUnit.DAYS.between(today, nextPaymentDate);
	            LocalDateTime dueDateTime = nextPaymentDate.atStartOfDay();

	            // ðŸŸ£ POSTPAID BILLING (End of Cycle or Overdue Cycle)
	            if (sub.getPlanType() == PlanType.POSTPAID) {
	                // Check if the current cycle has ended (or is overdue)
	                if (!today.isBefore(nextPaymentDate)) {

	                    // ðŸ”¥ FIX 1: Check for PENDING Dunning Event
	                    // If an event exists, the subscription is overdue and its overdue bill 
	                    // will be generated by Section 2 (Generate Overdue Bills).
	                    boolean hasPendingDunningEvent = eventRepo.existsByCustomerCustomerIdAndServiceNameAndStatus(
	                        customer.getCustomerId(), sub.getServiceName(), "PENDING"
	                    );

	                    if (hasPendingDunningEvent) {
	                        log.warn("Skipping Postpaid EOC for {} due to PENDING Dunning Event. Dunning will handle the bill.", sub.getServiceName());
	                        
	                        // CRITICAL: We MUST NOT move the cycle forward here if the customer hasn't paid.
	                        // Moving the cycle forward would remove the overdue state.
	                        continue; 
	                    }
	                    
	                    // FIX 2: Check for existing EOC bill (only runs if no Dunning Event is pending)
	                    boolean exists = billRepo.existsByCustomerCustomerIdAndServiceNameAndDueDate(
	                        customer.getCustomerId(), sub.getServiceName(), dueDateTime
	                    );

	                    if (exists) {
	                        log.info("Postpaid cycle {} already billed/checked. Skipping generation.", nextPaymentDate);
	                        continue;
	                    }

	                    // ðŸ”¥ --- FIX: Robust Usage Calculation ---
	                    BigDecimal totalAmount = calculatePostpaidAmount(sub);
	                    // Add other 'else if' blocks for other Postpaid services
	                    // --- END FIX ---

	                    if (totalAmount.compareTo(BigDecimal.ZERO) > 0) {
	                        Bill bill = createBaseBill(customer, sub, totalAmount, dueDateTime.plusDays(7), "PENDING",
	                                "Postpaid bill for usage period ending " + nextPaymentDate);
	                        billRepo.save(bill);
	                        log.info("ðŸ“… Postpaid bill generated with amount {}. Cycle moved.", totalAmount);
	                    } else {
	                        log.info("Skipping $0 Postpaid bill for cycle {}. Moving cycle forward.", nextPaymentDate);
	                    }

	                    // CRITICAL: Cycle Move MUST happen immediately after cycle end
	                    sub.setCall_usage_minutes(0);
	                    sub.setData_usage_gb(0);
	                    sub.setSms_count(0);
	                    sub.setLastPaymentDate(nextPaymentDate);
	                    sub.updateNextPaymentDate(); // Moves nextPaymentDate forward
	                    subRepo.save(sub);
	                }
	            }

	            // ðŸŸ¢ PREPAID BILLING (Upcoming Notification)
	            else if (sub.getPlanType() == PlanType.PREPAID) {
	                // (This logic was already correct)
	                if (daysUntilPayment >= 0 && daysUntilPayment <= 5) {
	                    if (!billRepo.existsByCustomerCustomerIdAndServiceNameAndDueDate(customer.getCustomerId(),
	                            sub.getServiceName(), dueDateTime)) {
	                        BigDecimal amount = sub.getDueAmount() != null ? sub.getDueAmount() : BigDecimal.ZERO;
	                        Bill bill = createBaseBill(customer, sub, amount, dueDateTime, "PENDING",
	                                "Generated 5 days before due date");
	                        billRepo.save(bill);
	                        log.info("âœ… Prepaid upcoming bill generated...");
	                    }
	                }
	            }
	        }
	    }

	    // 2. ðŸš¨ Generate Overdue Bills (From Dunning Events)
	    List<DunningEvent> pendingEvents = eventRepo.findByStatus("PENDING");

	    for (DunningEvent ev : pendingEvents) {

	        if (ev.getOriginalDueDate() == null) {
	            log.warn("Skipping DunningEvent ID {} due to missing originalDueDate.", ev.getId());
	            continue;
	        }

	        if (billRepo.existsByDunningEvent(ev)) {
	            log.info("Skipping duplicate bill for event ID={}", ev.getId());
	            continue;
	        }

	        // ðŸ”¥ --- FIX: Ultimate Unique Subscription Finder ---
	        Customer c = ev.getCustomer();
	        LocalDate cycleEndDate = ev.getOriginalDueDate().toLocalDate();

	        // 1. Get the rule applied to this event
	        DunningRule appliedRule = ev.getAppliedRule();
	        if (appliedRule == null) {
	            log.error("DunningEvent ID {} has no appliedRule. Cannot determine PlanType.", ev.getId());
	            continue;
	        }

	        // 2. Get the PlanType from the rule
	        PlanType planType = appliedRule.getPlanType();
	        if (planType == null) {
	            log.error("DunningRule ID {} has no PlanType. Cannot find unique subscription.", appliedRule.getId());
	            continue;
	        }

	        // 3. Find the subscription using the *truly unique* combination
	        ServiceSubscription sub = subRepo
	            .findByCustomerCustomerIdAndServiceNameAndPlanTypeAndNextPaymentDate(
	                c.getCustomerId(),
	                ev.getServiceName(),
	                planType, // <-- The missing piece for uniqueness
	                cycleEndDate
	            ).orElse(null);

	        if (sub == null) {
	            log.error("Could not find a unique subscription for Event ID {}. Data mismatch.", ev.getId());
	            continue;
	        }
	        // --- END FIX ---

	        BigDecimal amount = (sub.getDueAmount() != null) ? sub.getDueAmount() : BigDecimal.valueOf(1000);

	        // Bill creation
	        Bill b = new Bill();
	        b.setCustomer(c);
	        b.setServiceName(ev.getServiceName());
	        b.setAmount(amount);
	        b.setDueDate(ev.getOriginalDueDate());
	        b.setStatus("OVERDUE");
	        b.setCreatedAt(LocalDateTime.now());

	        long daysOverdue = ChronoUnit.DAYS.between(b.getDueDate().toLocalDate(), today);
	        b.setOverdueDays((int) daysOverdue);

	        b.setDescription("Generated from overdue event triggered on " + ev.getCreatedAt().toLocalDate());
	        b.setDunningEvent(ev);
	        billRepo.save(b);

	        log.info("ðŸš¨ Overdue bill generated for customer={} service={}", c.getCustomerId(), ev.getServiceName());
	    }

	    // 3. â° Auto Mark Bills Overdue
	    autoMarkOverdueBills();

	    log.info("ðŸ’¸ Scheduled billing and dunning cycle completed.");
	}

	// Helper method to reduce duplicate code
	private Bill createBaseBill(Customer customer, ServiceSubscription sub, BigDecimal amount, LocalDateTime dueDate,
			String status, String description) {
		Bill bill = new Bill();
		bill.setCustomer(customer);
		bill.setServiceName(sub.getServiceName());
		bill.setAmount(amount);
		bill.setDueDate(dueDate);
		bill.setStatus(status);
		bill.setCreatedAt(LocalDateTime.now());
		bill.setOverdueDays(0);
		bill.setDescription(description);
		return bill;
	}
	// Note: You need to add a findFirstByCustomerCustomerIdAndServiceName(Long
	// customerId, String serviceName)
	// method to your ServiceSubscriptionRepository interface.

	// âœ… Automatically mark overdue bills
	@Scheduled(fixedRate = 86400000)
	public void autoMarkOverdueBills() {
		List<Bill> bills = billRepo.findAll();
		LocalDateTime now = LocalDateTime.now();

		for (Bill bill : bills) {
			if ("PENDING".equalsIgnoreCase(bill.getStatus()) && bill.getDueDate().isBefore(now)) {
				bill.setStatus("OVERDUE");
				long daysOverdue = java.time.Duration.between(bill.getDueDate(), now).toDays();
				bill.setOverdueDays((int) daysOverdue);
				billRepo.save(bill);

				log.info("Bill marked as overdue: {} service={} overdueDays={}", bill.getBillId(),
						bill.getServiceName(), bill.getOverdueDays());
			}
		}
	}

	@Override
	public Bill createBill(Bill bill) {
		if (bill.getCustomer() == null || bill.getCustomer().getCustomerId() == null) {
			throw new CustomerNotFoundException("Customer is required for bill creation");
		}
		return billRepo.save(bill);
	}

	@Override
	public Bill getBillById(Long id) {
		return billRepo.findById(id).orElse(null);
	}

	@Override
	public List<Bill> getBillsByCustomer(Long customerId) {
		return billRepo.findByCustomerCustomerId(customerId);
	}

	@Override
	public List<Bill> getAllBills() {
		return billRepo.findAll();
	}

	@Override
	public List<BillDTO> getCurrentBills(Long customerId) {
		if (!customerRepo.existsById(customerId)) {
			throw new CustomerNotFoundException("Customer not found: " + customerId);
		}
		List<Bill> bills = billRepo.findByCustomerCustomerIdAndStatus(customerId, "PENDING");
		return bills.stream().map(this::toDTO).collect(Collectors.toList());
	}

	@Override
	public List<BillDTO> getPastBills(Long customerId) {
		if (!customerRepo.existsById(customerId)) {
			throw new CustomerNotFoundException("Customer not found: " + customerId);
		}
		List<Bill> bills = billRepo.findByCustomerCustomerIdAndStatus(customerId, "PAID");
		return bills.stream().map(this::toDTO).collect(Collectors.toList());
	}

	@Override
	public BillDTO toDTO(Bill bill) {
		BillDTO dto = new BillDTO();
		dto.setBillId(bill.getBillId());
		dto.setCustomerId(bill.getCustomer().getCustomerId());
		dto.setServiceName(bill.getServiceName());
		dto.setAmount(bill.getAmount());
		dto.setStatus(bill.getStatus());
		dto.setDueDate(bill.getDueDate());
		dto.setPaidAt(bill.getPaymentDate());
		dto.setDaysOverdue(bill.getOverdueDays());
//        dto.setPlanType(subRepo.getPlanType().name());
		return dto;
	}

	@Override
	public Bill markBillAsPaid(Bill bill) {
		if (bill != null) {
			bill.setPaid(true);
			bill.setPaymentDate(LocalDateTime.now());
			bill.setStatus("PAID");
			billRepo.save(bill);

			// --- ðŸ”§ CURING LOGIC ---
			Customer customer = bill.getCustomer();
			List<DunningEvent> openEvents = eventRepo.findByCustomerCustomerIdAndStatus(customer.getCustomerId(),
					"PENDING");
			for (DunningEvent ev : openEvents) {
				ev.setStatus("RESOLVED");
				ev.setResolvedAt(LocalDateTime.now());
			}
			eventRepo.saveAll(openEvents);

			// Reactivate any blocked services
			List<ServiceSubscription> subs = subRepo.findByCustomerCustomerId(customer.getCustomerId());
			for (ServiceSubscription sub : subs) {
				if ("BLOCKED".equals(sub.getStatus())) {
					sub.setStatus("ACTIVE");
				}
				sub.setLastPaymentDate(LocalDate.now());
				sub.updateNextPaymentDate();
			}
			subRepo.saveAll(subs);

			return bill;
		}
		return null;
	}

	// BillServiceImpl.java
	@Override
	public boolean billExists(Customer customer, ServiceSubscription sub, LocalDate dueDate) {
	    return billRepo.existsByCustomerAndServiceNameAndDueDate(
	        customer, 
	        sub.getServiceName(), 
	        dueDate.atStartOfDay() // Convert LocalDate to LocalDateTime
	    );
	}

	@Override
	@Transactional
	public void generateUpcomingPostpaidBill(Customer customer, ServiceSubscription sub, LocalDate dueDate) {
	    if (!billExists(customer, sub, dueDate)) {
	        Bill bill = new Bill();
	        bill.setCustomer(customer);
	        bill.setServiceName(sub.getServiceName());
	        bill.setAmount(sub.getDueAmount());
	        bill.setDueDate(dueDate.atStartOfDay());
	        bill.setStatus("PENDING");
	        bill.setCreatedAt(LocalDateTime.now());
	        bill.setDescription("Generated " + EOC_TRIGGER_DAYS_BEFORE + " days before due date");
	        billRepo.save(bill);
	        log.info("Generated upcoming postpaid bill: customer={} service={} dueDate={}", 
                customer.getCustomerId(), sub.getServiceName(), dueDate);
	    }
	}

	@Override
	public void generateUpcomingPrepaidBill(Customer customer, ServiceSubscription sub, LocalDate dueDate) {
		// TODO Auto-generated method stub
		
	}

	private BigDecimal calculatePostpaidAmount(ServiceSubscription sub) {
	    BigDecimal totalAmount = BigDecimal.ZERO;
	    String serviceName = sub.getServiceName();

	    if ("Mobile".equalsIgnoreCase(serviceName)) {
	        totalAmount = totalAmount
	            .add(BigDecimal.valueOf(sub.getCall_usage_minutes() * 0.5))
	            .add(BigDecimal.valueOf(sub.getData_usage_gb() * 10))
	            .add(BigDecimal.valueOf(sub.getSms_count() * 0.25));
	    } else if ("Broadband".equalsIgnoreCase(serviceName)) {
	        totalAmount = totalAmount
	            .add(BigDecimal.valueOf(sub.getData_usage_gb() * 5))
	            .add(BigDecimal.valueOf(50)); // Base fee
	    }
	    
	    return totalAmount.max(sub.getDueAmount() != null ? sub.getDueAmount() : BigDecimal.ZERO);
	}
}
